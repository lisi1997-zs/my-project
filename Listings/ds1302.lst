C51 COMPILER V9.60.7.0   DS1302                                                            12/26/2025 21:08:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN .\Objects\ds1302.obj
COMPILER INVOKED BY: D:\ARMMDK\mdkarm\C51\BIN\C51.EXE ds1302.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\ds1302.lst) TABS(2) OBJECT(.\Objects\ds1302.obj)

line level    source

   1          #include "reg52.h"
   2          #include "ds1302.h"
   3          
   4          // =========================================================
   5          // ⚠警告：请务必确认以下引脚与你的开发板原理图一致！
   6          // 如果你的“简单代码”里用的不是这几个脚，请必须改掉！
   7          // =========================================================
   8          sbit DS1302_CLK = P3^6;  // 对应你的 SCK
   9          sbit DS1302_IO  = P3^4;  // 对应你的 IO/DAT
  10          sbit DS1302_RST = P3^5;  // 对应你的 RST/CE
  11          
  12          // 简单的短延时，确保波形稳定
  13          void DS1302_Delay(void) {
  14   1          unsigned char i;
  15   1          for(i = 0; i < 2; i++); 
  16   1      }
  17          
  18          // 标准的单字节写入（上升沿写入）
  19          void DS1302_WriteByte(unsigned char dat) {
  20   1          unsigned char i;
  21   1          for(i = 0; i < 8; i++) {
  22   2              DS1302_IO = dat & 0x01; // 1. 先准备数据
  23   2              DS1302_Delay();
  24   2              DS1302_CLK = 1;         // 2. 拉高时钟（写入数据）
  25   2              DS1302_Delay();
  26   2              DS1302_CLK = 0;         // 3. 拉低时钟
  27   2              DS1302_Delay();
  28   2              dat >>= 1;              // 4. 移位
  29   2          }
  30   1      }
  31          
  32          // 标准的单字节读取（下降沿读取数据有效性）
  33          unsigned char DS1302_ReadByte(void) {
  34   1          unsigned char i, dat = 0;
  35   1          for(i = 0; i < 8; i++) {
  36   2              dat >>= 1;
  37   2              // DS1302 在时钟下降沿后输出数据，所以此时直接读取
  38   2              if(DS1302_IO) {
  39   3                  dat |= 0x80;
  40   3              }
  41   2              
  42   2              // 产生一个时钟脉冲，为下一位数据做准备
  43   2              DS1302_CLK = 1;
  44   2              DS1302_Delay();
  45   2              DS1302_CLK = 0;
  46   2              DS1302_Delay();
  47   2          }
  48   1          return dat;
  49   1      }
  50          
  51          // 写入寄存器：先写命令，再写数据
  52          void DS1302_Write(unsigned char addr, unsigned char dat) {
  53   1          DS1302_RST = 0;
  54   1          DS1302_CLK = 0;
C51 COMPILER V9.60.7.0   DS1302                                                            12/26/2025 21:08:39 PAGE 2   

  55   1          DS1302_RST = 1; // 开启通信
  56   1          
  57   1          DS1302_WriteByte(addr); // 写地址
  58   1          DS1302_WriteByte(dat);  // 写数据
  59   1          
  60   1          DS1302_RST = 0; // 结束通信
  61   1      }
  62          
  63          // 读取寄存器：先写命令，再读数据
  64          unsigned char DS1302_Read(unsigned char addr) {
  65   1          unsigned char temp;
  66   1          DS1302_RST = 0;
  67   1          DS1302_CLK = 0;
  68   1          DS1302_RST = 1; // 开启通信
  69   1          
  70   1          DS1302_WriteByte(addr); // 写地址
  71   1          temp = DS1302_ReadByte(); // 读数据
  72   1          
  73   1          DS1302_RST = 0; // 结束通信
  74   1          // 注意：读取完后必须把 IO 口复位，防止干扰
  75   1          DS1302_CLK = 0;
  76   1          return temp;
  77   1      }
  78          
  79          // 初始化 DS1302 (解决时钟暂停问题)
  80          void DS1302_Init(void) {
  81   1          unsigned char sec;
  82   1          
  83   1          // 1. 解除写保护
  84   1          DS1302_Write(0x8E, 0x00);
  85   1          
  86   1          // 2. 读取秒寄存器，检查是否处于 Halt (暂停) 状态
  87   1          sec = DS1302_Read(0x81);
  88   1          if(sec & 0x80) { // 如果最高位是1，说明时钟停了
  89   2              DS1302_Write(0x80, 0x00); // 写入 0 秒，并启动时钟
  90   2          }
  91   1          
  92   1          // 3. 再次解除写保护 (为了后续正常写入时间)
  93   1          DS1302_Write(0x8E, 0x00);
  94   1      }
  95          
  96          // 读取时间到数组
  97          void DS1302_ReadTime(unsigned char *t) {
  98   1          t[0] = DS1302_Read(0x81); // 秒
  99   1          t[1] = DS1302_Read(0x83); // 分
 100   1          t[2] = DS1302_Read(0x85); // 时
 101   1          t[3] = DS1302_Read(0x87); // 日
 102   1          t[4] = DS1302_Read(0x89); // 月
 103   1          t[5] = DS1302_Read(0x8B); // 周
 104   1          t[6] = DS1302_Read(0x8D); // 年
 105   1      }
 106          
 107          // 设置时间
 108          void DS1302_SetTime(unsigned char *t) {
 109   1          DS1302_Write(0x8E, 0x00); // 关闭写保护
 110   1          
 111   1          DS1302_Write(0x80, t[0]); // 秒
 112   1          DS1302_Write(0x82, t[1]); // 分
 113   1          DS1302_Write(0x84, t[2]); // 时
 114   1          DS1302_Write(0x86, t[3]); // 日
 115   1          DS1302_Write(0x88, t[4]); // 月
 116   1          DS1302_Write(0x8A, t[5]); // 周
C51 COMPILER V9.60.7.0   DS1302                                                            12/26/2025 21:08:39 PAGE 3   

 117   1          DS1302_Write(0x8C, t[6]); // 年
 118   1          
 119   1          DS1302_Write(0x8E, 0x80); // 打开写保护
 120   1      }
 121          
 122          unsigned char DS1302_ReadRam(unsigned char ram_index) {
 123   1          unsigned char addr = 0xC0 + (ram_index << 1);
 124   1          return DS1302_Read(addr | 0x01);
 125   1      }
 126          
 127          void DS1302_WriteRam(unsigned char ram_index, unsigned char dat) {
 128   1          unsigned char addr = 0xC0 + (ram_index << 1);
 129   1          DS1302_Write(0x8E, 0x00);
 130   1          DS1302_Write(addr, dat);
 131   1          DS1302_Write(0x8E, 0x80);
 132   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    328    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
