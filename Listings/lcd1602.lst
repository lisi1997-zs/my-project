C51 COMPILER V9.60.7.0   LCD1602                                                           12/26/2025 20:45:32 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LCD1602
OBJECT MODULE PLACED IN .\Objects\lcd1602.obj
COMPILER INVOKED BY: D:\ARMMDK\mdkarm\C51\BIN\C51.EXE lcd1602.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\lcd1602.lst) TABS(2) OBJECT(.\Objects\lcd1602.obj)

line level    source

   1          #include "reg52.h"
   2          #include "lcd1602.h"
   3          #include <math.h>  // 添加数学头文件
   4          
   5          sbit RS = P2^6;
   6          sbit RW = P2^5;
   7          sbit EN = P2^7;
   8          #define LCD_PORT P0
   9          
  10          void DelayUs(unsigned int us){ while(us--); }
  11          
  12          void LCD_WriteCmd(unsigned char cmd){
  13   1          RS=0; RW=0; LCD_PORT=cmd; EN=1; 
  14   1          DelayUs(50); 
  15   1          EN=0;
  16   1          
  17   1          // 【新增】如果是清屏指令，额外多等一会
  18   1          // 0x01 是清屏，0x02 是光标归位，这两个特别慢
  19   1          if(cmd == 0x01 || cmd == 0x02) {
  20   2              // 这里需要一个毫秒级的延时，由于你在 lcd1602.c 里只有 DelayUs
  21   2              // 可以简单地调用多次 DelayUs，或者直接用循环
  22   2              unsigned int i = 2000; 
  23   2              while(i--); // 强行延时约 2ms
  24   2          }
  25   1      }
  26          
  27          void LCD_WriteData(unsigned char dat){
  28   1          RS=1; RW=0; LCD_PORT=dat; EN=1; DelayUs(50); EN=0;
  29   1      }
  30          
  31          void LCD_ShowString(unsigned char row, unsigned char col, char *str){
  32   1          unsigned char addr;
  33   1          addr = (row ? 0x40 : 0x00) + col;
  34   1          LCD_WriteCmd(0x80 | addr);
  35   1          while(*str) LCD_WriteData(*str++);
  36   1      }
  37          
  38          void LCD_ShowNum(unsigned char row, unsigned char col, unsigned int num, unsigned char len){
  39   1          unsigned char i;
  40   1          char buffer[6];  // 固定大小的缓冲区
  41   1          
  42   1          // 确保数字在合理范围内
  43   1          if(len > 5) len = 5;
  44   1          
  45   1          // 将数字转换为字符串
  46   1          for(i = 0; i < len; i++){
  47   2              buffer[len - i - 1] = (num % 10) + '0';
  48   2              num /= 10;
  49   2          }
  50   1          buffer[len] = '\0';  // 字符串结束符
  51   1          
  52   1          // 显示字符串
  53   1          LCD_ShowString(row, col, buffer);
  54   1      }
C51 COMPILER V9.60.7.0   LCD1602                                                           12/26/2025 20:45:32 PAGE 2   

  55          
  56          
  57          void LCD_Init(void){
  58   1          LCD_WriteCmd(0x38);
  59   1          LCD_WriteCmd(0x0C);
  60   1          LCD_WriteCmd(0x06);
  61   1          LCD_WriteCmd(0x01);
  62   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    239    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
